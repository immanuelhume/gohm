{{- define "find-many" -}}

{{ $model := .Name.Name -}}
{{ $nsmodel := printf "%s.%s" .Pkg.Name .Name.Name -}}
{{ $numodel := lowerFirst .Name.Name -}}
{{ $rcv := toReceiverCase .Name.Name -}}
{{ $findopt := printf "%s%s" $model "FindOpt" -}}

// Returns a slice of all {{ $model }} models which fulfill the provided conditions.
func({{ $rcv }} *{{ $model }}) FindMany(ctx context.Context, options *{{ $findopt }}) ([]{{ $nsmodel }}, error) {
	_v := reflect.ValueOf(options).Elem()
	_t := _v.Type()

	var _cmds []*redis.StringSliceCmd
	var _hits [][]string
	var _keys []string

	var _raw []*redis.StringStringMapCmd
	var _results []{{ $nsmodel }}

	_pipe := {{ $rcv }}.rdb.Pipeline()

	for i := 0; i < _v.NumField(); i++ {
		_val := _v.Field(i)
		if _val.IsNil() {
			continue
		}
		_field := _t.Field(i).Name

		_key := genKey("{{ $model }}", _field, _val.Elem())
		_cmds = append(_cmds, _pipe.SMembers(ctx, _key))
	}

	_, err := _pipe.Exec(ctx)
	if err != nil {
		return nil, err
	}

	for _, cmd := range _cmds {
		_hits = append(_hits, cmd.Val())
	}
	_keys = intersect(_hits)

	for _, k := range _keys {
		_raw = append(_raw, _pipe.HGetAll(ctx, k))
	}
	_, err = _pipe.Exec(ctx)
	if err != nil {
		return nil, err
	}

	for _, m := range _raw {
		v := m.Val()

		{{ range .TLsFields -}}
		{{ $raw := printf "v[%q]" .Name -}}
		{{ template "from-string.go.tmpl" newMarshallData . $raw .Name "nil" }}
		{{ end }}

		{{ $rcv }} := {{ $nsmodel }}{
			{{ range .TLsFields }}
			{{- .Name }}: {{ .Name }},
			{{ end }}
		}
		
		_results = append(_results, {{ $rcv }})
	}
	return _results, nil
}

{{- end -}}