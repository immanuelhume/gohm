package gohm

import (
	"context"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/go-redis/redis/v8"
	"github.com/google/uuid"

	{{ .TImports }}
)

type GohmClient struct {
	*redis.Client

	{{ .TGohmFields }}
}

// Works just like redis.NewClient and returns a Redis client.
func NewClient(opt *redis.Options) *GohmClient {
	redisClient := redis.NewClient(opt)

	gohmClient := &GohmClient{
		redisClient, 
		{{ range .Entities -}}
		&{{ .Name.Name }}{rdb: redisClient},
		{{ end }}
		}
	
	return gohmClient
}

{{ range .Entities }}
{{ $lower := toLower .Name.Name }}
{{ $rcv := toReceiverCase .Name.Name}}
{{ $ns := .TNamespacedEntity }}
type {{ .Name.Name }} struct {
	rdb *redis.Client
}

// Saves one {{ .Name.Name }} into Redis. Returns either an error or nil.
func({{ $rcv }} *{{ .Name.Name }}) Save(ctx context.Context, {{ $lower }} *{{ .TNamespacedEntity }}) error {
	_pipe := {{ $rcv }}.rdb.Pipeline()
	_enKey := genKey("{{ .Name.Name }}", uuid.NewString())
	_vMap := make(map[string]interface{})
	{{ range .TLsFields }}
	{{ $raw := .Name | printf "%s.%s" $lower -}}
	_vMap["{{ .Name }}"] = {{ template "to-string.go.tmpl" newMarshallData . $raw .Name "nil" -}} 
	{{ end }}

	for k, v := range _vMap {
		_pipe.SAdd(ctx, genKey("{{ .Name.Name }}", k, v), _enKey)
	}
	_pipe.HSet(ctx, _enKey, _vMap)

	_, err := _pipe.Exec(ctx)
	return err
}

// Returns as a slice all {{ .Name.Name }}(s) which fulfill the provided filter conditions.
func({{ $rcv }} *{{ .Name.Name }}) FindMany(ctx context.Context, filter *{{ .Name.Name }}Filter) ([]{{ .TNamespacedEntity }}, error) {
	_v := reflect.ValueOf(filter).Elem()
	_t := reflect.TypeOf(filter).Elem()

	_pipe := {{ $rcv }}.rdb.Pipeline()
	var _cmds []*redis.StringSliceCmd
	var _hits [][]string

	var _raw []*redis.StringStringMapCmd
	var _results []{{ .TNamespacedEntity }}

	for i := 0; i < _v.NumField(); i++ {
		_val := _v.Field(i)
		if _val.IsNil() {
			continue
		}
		_field := _t.Field(i).Name

		_key := genKey("{{ .Name.Name }}", _field, _val.Elem())
		_cmds = append(_cmds, _pipe.SMembers(ctx, _key))
	}

	_, err := _pipe.Exec(ctx)
	if err != nil {
		return []{{ .TNamespacedEntity }}{}, err
	}

	for _, cmd := range _cmds {
		_hits = append(_hits, cmd.Val())
	}
	_keys := intersect(_hits...)

	for _, k := range _keys {
		_raw = append(_raw, _pipe.HGetAll(ctx, k))
	}
	_, err = _pipe.Exec(ctx)
	if err != nil {
		return []{{ .TNamespacedEntity }}{}, err
	}

	for _, m := range _raw {
		v := m.Val()

		{{ range .TLsFields -}}
		{{ $raw := .Name | printf "v[%q]" -}}
		{{ template "from-string.go.tmpl" newMarshallData . $raw .Name "nil" }}
		{{ end }}

		{{ $rcv }} := {{ .TNamespacedEntity }}{
			{{ range .TLsFields }}
			{{- .Name }}: {{ .Name }},
			{{ end }}
		}
		
		_results = append(_results, {{ $rcv }})
	}
	return _results, nil
}

// Utility type used for searching {{ .Name.Name }} entities. Every field
// must be a pointer to differentiate between zero-values and nil fields.
type {{ .Name.Name }}Filter struct {
	{{ range .TPtrFields}}
	{{- . }}
	{{ end }}
}
{{ end }}

// Helper function to insert ':'s for redis keys.
func genKey(tags ...interface{}) string {
	n := len(tags)
	sl := []string{}
	for i := 0; i < n; i++ {
		sl = append(sl, "%v")
	}
	format := strings.Join(sl, ":")
	return fmt.Sprintf(format, tags...)
}

// Finds the intersection of n slices.
func intersect(slices ...[]string) []string {
	if len(slices) == 1 {
		return slices[0]
	}

	head := make(map[string]bool)

	for _, v := range slices[0] {
		head[v] = true
	}
	for _, sl := range slices[1:] {
		var hits []string
		for _, v := range sl {
			_, ok := head[v]
			if ok {
				hits = append(hits, v)
			}
		}
		head = map[string]bool{}
		for _, v := range hits {
			head[v] = true
		}
	}

	var res []string
	for k := range head {
		res = append(res, k)
	}
	return res
}

// Bool stores v in a new bool value and returns a pointer to it.
func Bool(v bool) *bool { return &v }

// Int stores v in a new int value and returns a pointer to it.
func Int(v int) *int { return &v }

// Float32 stores v in a new float32 value and returns a pointer to it.
func Float32(v float32) *float32 { return &v }

// Float64 stores v in a new float64 value and returns a pointer to it.
func Float64(v float64) *float64 { return &v }

// String stores v in a new string value and returns a pointer to it.
func String(v string) *string { return &v }